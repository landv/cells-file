// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-update.proto

package update

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedUpdateServiceServers     = make(map[string]UpdateServiceEnhancedServer)
	enhancedUpdateServiceServersLock = sync.RWMutex{}
)

type NamedUpdateServiceServer interface {
	UpdateServiceServer
	Name() string
}
type UpdateServiceEnhancedServer map[string]NamedUpdateServiceServer

func (m UpdateServiceEnhancedServer) UpdateRequired(ctx context.Context, r *UpdateRequest) (*UpdateResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method UpdateRequired should have a context")
	}
	enhancedUpdateServiceServersLock.RLock()
	defer enhancedUpdateServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.UpdateRequired(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRequired not implemented")
}

func (m UpdateServiceEnhancedServer) ApplyUpdate(ctx context.Context, r *ApplyUpdateRequest) (*ApplyUpdateResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method ApplyUpdate should have a context")
	}
	enhancedUpdateServiceServersLock.RLock()
	defer enhancedUpdateServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ApplyUpdate(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ApplyUpdate not implemented")
}
func (m UpdateServiceEnhancedServer) mustEmbedUnimplementedUpdateServiceServer() {}
func RegisterUpdateServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedUpdateServiceServer) {
	enhancedUpdateServiceServersLock.Lock()
	defer enhancedUpdateServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUpdateServiceServers[addr]
	if !ok {
		m = UpdateServiceEnhancedServer{}
		enhancedUpdateServiceServers[addr] = m
		RegisterUpdateServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterUpdateServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedUpdateServiceServersLock.Lock()
	defer enhancedUpdateServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUpdateServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedUpdateServerServiceServers     = make(map[string]UpdateServerServiceEnhancedServer)
	enhancedUpdateServerServiceServersLock = sync.RWMutex{}
)

type NamedUpdateServerServiceServer interface {
	UpdateServerServiceServer
	Name() string
}
type UpdateServerServiceEnhancedServer map[string]NamedUpdateServerServiceServer

// Ask the update server if there are any available updates

func (m UpdateServerServiceEnhancedServer) CheckForUpdate(ctx context.Context, r *UpdateRequest) (*UpdateResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CheckForUpdate should have a context")
	}
	enhancedUpdateServerServiceServersLock.RLock()
	defer enhancedUpdateServerServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CheckForUpdate(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CheckForUpdate not implemented")
}

func (m UpdateServerServiceEnhancedServer) PublishPackage(ctx context.Context, r *PublishPackageRequest) (*PublishPackageResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PublishPackage should have a context")
	}
	enhancedUpdateServerServiceServersLock.RLock()
	defer enhancedUpdateServerServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PublishPackage(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PublishPackage not implemented")
}

func (m UpdateServerServiceEnhancedServer) ListPackages(ctx context.Context, r *ListPackagesRequest) (*ListPackagesResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method ListPackages should have a context")
	}
	enhancedUpdateServerServiceServersLock.RLock()
	defer enhancedUpdateServerServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.ListPackages(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method ListPackages not implemented")
}

func (m UpdateServerServiceEnhancedServer) DeletePackage(ctx context.Context, r *DeletePackageRequest) (*DeletePackageResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method DeletePackage should have a context")
	}
	enhancedUpdateServerServiceServersLock.RLock()
	defer enhancedUpdateServerServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.DeletePackage(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeletePackage not implemented")
}
func (m UpdateServerServiceEnhancedServer) mustEmbedUnimplementedUpdateServerServiceServer() {}
func RegisterUpdateServerServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedUpdateServerServiceServer) {
	enhancedUpdateServerServiceServersLock.Lock()
	defer enhancedUpdateServerServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUpdateServerServiceServers[addr]
	if !ok {
		m = UpdateServerServiceEnhancedServer{}
		enhancedUpdateServerServiceServers[addr] = m
		RegisterUpdateServerServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterUpdateServerServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedUpdateServerServiceServersLock.Lock()
	defer enhancedUpdateServerServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedUpdateServerServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
