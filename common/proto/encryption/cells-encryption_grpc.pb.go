// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package encryption

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserKeyStoreClient is the client API for UserKeyStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserKeyStoreClient interface {
	AddKey(ctx context.Context, in *AddKeyRequest, opts ...grpc.CallOption) (*AddKeyResponse, error)
	GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error)
	AdminListKeys(ctx context.Context, in *AdminListKeysRequest, opts ...grpc.CallOption) (*AdminListKeysResponse, error)
	AdminCreateKey(ctx context.Context, in *AdminCreateKeyRequest, opts ...grpc.CallOption) (*AdminCreateKeyResponse, error)
	AdminDeleteKey(ctx context.Context, in *AdminDeleteKeyRequest, opts ...grpc.CallOption) (*AdminDeleteKeyResponse, error)
	AdminExportKey(ctx context.Context, in *AdminExportKeyRequest, opts ...grpc.CallOption) (*AdminExportKeyResponse, error)
	AdminImportKey(ctx context.Context, in *AdminImportKeyRequest, opts ...grpc.CallOption) (*AdminImportKeyResponse, error)
}

type userKeyStoreClient struct {
	cc grpc.ClientConnInterface
}

func NewUserKeyStoreClient(cc grpc.ClientConnInterface) UserKeyStoreClient {
	return &userKeyStoreClient{cc}
}

func (c *userKeyStoreClient) AddKey(ctx context.Context, in *AddKeyRequest, opts ...grpc.CallOption) (*AddKeyResponse, error) {
	out := new(AddKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AddKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) GetKey(ctx context.Context, in *GetKeyRequest, opts ...grpc.CallOption) (*GetKeyResponse, error) {
	out := new(GetKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/GetKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) AdminListKeys(ctx context.Context, in *AdminListKeysRequest, opts ...grpc.CallOption) (*AdminListKeysResponse, error) {
	out := new(AdminListKeysResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AdminListKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) AdminCreateKey(ctx context.Context, in *AdminCreateKeyRequest, opts ...grpc.CallOption) (*AdminCreateKeyResponse, error) {
	out := new(AdminCreateKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AdminCreateKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) AdminDeleteKey(ctx context.Context, in *AdminDeleteKeyRequest, opts ...grpc.CallOption) (*AdminDeleteKeyResponse, error) {
	out := new(AdminDeleteKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AdminDeleteKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) AdminExportKey(ctx context.Context, in *AdminExportKeyRequest, opts ...grpc.CallOption) (*AdminExportKeyResponse, error) {
	out := new(AdminExportKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AdminExportKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userKeyStoreClient) AdminImportKey(ctx context.Context, in *AdminImportKeyRequest, opts ...grpc.CallOption) (*AdminImportKeyResponse, error) {
	out := new(AdminImportKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.UserKeyStore/AdminImportKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserKeyStoreServer is the server API for UserKeyStore service.
// All implementations must embed UnimplementedUserKeyStoreServer
// for forward compatibility
type UserKeyStoreServer interface {
	AddKey(context.Context, *AddKeyRequest) (*AddKeyResponse, error)
	GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error)
	AdminListKeys(context.Context, *AdminListKeysRequest) (*AdminListKeysResponse, error)
	AdminCreateKey(context.Context, *AdminCreateKeyRequest) (*AdminCreateKeyResponse, error)
	AdminDeleteKey(context.Context, *AdminDeleteKeyRequest) (*AdminDeleteKeyResponse, error)
	AdminExportKey(context.Context, *AdminExportKeyRequest) (*AdminExportKeyResponse, error)
	AdminImportKey(context.Context, *AdminImportKeyRequest) (*AdminImportKeyResponse, error)
	mustEmbedUnimplementedUserKeyStoreServer()
}

// UnimplementedUserKeyStoreServer must be embedded to have forward compatible implementations.
type UnimplementedUserKeyStoreServer struct {
}

func (UnimplementedUserKeyStoreServer) AddKey(context.Context, *AddKeyRequest) (*AddKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKey not implemented")
}
func (UnimplementedUserKeyStoreServer) GetKey(context.Context, *GetKeyRequest) (*GetKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
}
func (UnimplementedUserKeyStoreServer) AdminListKeys(context.Context, *AdminListKeysRequest) (*AdminListKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminListKeys not implemented")
}
func (UnimplementedUserKeyStoreServer) AdminCreateKey(context.Context, *AdminCreateKeyRequest) (*AdminCreateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminCreateKey not implemented")
}
func (UnimplementedUserKeyStoreServer) AdminDeleteKey(context.Context, *AdminDeleteKeyRequest) (*AdminDeleteKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminDeleteKey not implemented")
}
func (UnimplementedUserKeyStoreServer) AdminExportKey(context.Context, *AdminExportKeyRequest) (*AdminExportKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminExportKey not implemented")
}
func (UnimplementedUserKeyStoreServer) AdminImportKey(context.Context, *AdminImportKeyRequest) (*AdminImportKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminImportKey not implemented")
}
func (UnimplementedUserKeyStoreServer) mustEmbedUnimplementedUserKeyStoreServer() {}

// UnsafeUserKeyStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserKeyStoreServer will
// result in compilation errors.
type UnsafeUserKeyStoreServer interface {
	mustEmbedUnimplementedUserKeyStoreServer()
}

func RegisterUserKeyStoreServer(s grpc.ServiceRegistrar, srv UserKeyStoreServer) {
	s.RegisterService(&UserKeyStore_ServiceDesc, srv)
}

func _UserKeyStore_AddKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AddKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AddKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AddKey(ctx, req.(*AddKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_GetKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/GetKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).GetKey(ctx, req.(*GetKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_AdminListKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminListKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AdminListKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AdminListKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AdminListKeys(ctx, req.(*AdminListKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_AdminCreateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminCreateKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AdminCreateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AdminCreateKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AdminCreateKey(ctx, req.(*AdminCreateKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_AdminDeleteKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminDeleteKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AdminDeleteKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AdminDeleteKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AdminDeleteKey(ctx, req.(*AdminDeleteKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_AdminExportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminExportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AdminExportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AdminExportKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AdminExportKey(ctx, req.(*AdminExportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserKeyStore_AdminImportKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminImportKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserKeyStoreServer).AdminImportKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.UserKeyStore/AdminImportKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserKeyStoreServer).AdminImportKey(ctx, req.(*AdminImportKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserKeyStore_ServiceDesc is the grpc.ServiceDesc for UserKeyStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserKeyStore_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "encryption.UserKeyStore",
	HandlerType: (*UserKeyStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddKey",
			Handler:    _UserKeyStore_AddKey_Handler,
		},
		{
			MethodName: "GetKey",
			Handler:    _UserKeyStore_GetKey_Handler,
		},
		{
			MethodName: "AdminListKeys",
			Handler:    _UserKeyStore_AdminListKeys_Handler,
		},
		{
			MethodName: "AdminCreateKey",
			Handler:    _UserKeyStore_AdminCreateKey_Handler,
		},
		{
			MethodName: "AdminDeleteKey",
			Handler:    _UserKeyStore_AdminDeleteKey_Handler,
		},
		{
			MethodName: "AdminExportKey",
			Handler:    _UserKeyStore_AdminExportKey_Handler,
		},
		{
			MethodName: "AdminImportKey",
			Handler:    _UserKeyStore_AdminImportKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cells-encryption.proto",
}

// NodeKeyManagerClient is the client API for NodeKeyManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeKeyManagerClient interface {
	GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error)
	GetNodePlainSize(ctx context.Context, in *GetNodePlainSizeRequest, opts ...grpc.CallOption) (*GetNodePlainSizeResponse, error)
	SetNodeInfo(ctx context.Context, opts ...grpc.CallOption) (NodeKeyManager_SetNodeInfoClient, error)
	CopyNodeInfo(ctx context.Context, in *CopyNodeInfoRequest, opts ...grpc.CallOption) (*CopyNodeInfoResponse, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error)
	DeleteNodeKey(ctx context.Context, in *DeleteNodeKeyRequest, opts ...grpc.CallOption) (*DeleteNodeKeyResponse, error)
	DeleteNodeSharedKey(ctx context.Context, in *DeleteNodeSharedKeyRequest, opts ...grpc.CallOption) (*DeleteNodeSharedKeyResponse, error)
}

type nodeKeyManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeKeyManagerClient(cc grpc.ClientConnInterface) NodeKeyManagerClient {
	return &nodeKeyManagerClient{cc}
}

func (c *nodeKeyManagerClient) GetNodeInfo(ctx context.Context, in *GetNodeInfoRequest, opts ...grpc.CallOption) (*GetNodeInfoResponse, error) {
	out := new(GetNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/GetNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeKeyManagerClient) GetNodePlainSize(ctx context.Context, in *GetNodePlainSizeRequest, opts ...grpc.CallOption) (*GetNodePlainSizeResponse, error) {
	out := new(GetNodePlainSizeResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/GetNodePlainSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeKeyManagerClient) SetNodeInfo(ctx context.Context, opts ...grpc.CallOption) (NodeKeyManager_SetNodeInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &NodeKeyManager_ServiceDesc.Streams[0], "/encryption.NodeKeyManager/SetNodeInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeKeyManagerSetNodeInfoClient{stream}
	return x, nil
}

type NodeKeyManager_SetNodeInfoClient interface {
	Send(*SetNodeInfoRequest) error
	CloseAndRecv() (*SetNodeInfoResponse, error)
	grpc.ClientStream
}

type nodeKeyManagerSetNodeInfoClient struct {
	grpc.ClientStream
}

func (x *nodeKeyManagerSetNodeInfoClient) Send(m *SetNodeInfoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nodeKeyManagerSetNodeInfoClient) CloseAndRecv() (*SetNodeInfoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetNodeInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeKeyManagerClient) CopyNodeInfo(ctx context.Context, in *CopyNodeInfoRequest, opts ...grpc.CallOption) (*CopyNodeInfoResponse, error) {
	out := new(CopyNodeInfoResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/CopyNodeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeKeyManagerClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error) {
	out := new(DeleteNodeResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeKeyManagerClient) DeleteNodeKey(ctx context.Context, in *DeleteNodeKeyRequest, opts ...grpc.CallOption) (*DeleteNodeKeyResponse, error) {
	out := new(DeleteNodeKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/DeleteNodeKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeKeyManagerClient) DeleteNodeSharedKey(ctx context.Context, in *DeleteNodeSharedKeyRequest, opts ...grpc.CallOption) (*DeleteNodeSharedKeyResponse, error) {
	out := new(DeleteNodeSharedKeyResponse)
	err := c.cc.Invoke(ctx, "/encryption.NodeKeyManager/DeleteNodeSharedKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeKeyManagerServer is the server API for NodeKeyManager service.
// All implementations must embed UnimplementedNodeKeyManagerServer
// for forward compatibility
type NodeKeyManagerServer interface {
	GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error)
	GetNodePlainSize(context.Context, *GetNodePlainSizeRequest) (*GetNodePlainSizeResponse, error)
	SetNodeInfo(NodeKeyManager_SetNodeInfoServer) error
	CopyNodeInfo(context.Context, *CopyNodeInfoRequest) (*CopyNodeInfoResponse, error)
	DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error)
	DeleteNodeKey(context.Context, *DeleteNodeKeyRequest) (*DeleteNodeKeyResponse, error)
	DeleteNodeSharedKey(context.Context, *DeleteNodeSharedKeyRequest) (*DeleteNodeSharedKeyResponse, error)
	mustEmbedUnimplementedNodeKeyManagerServer()
}

// UnimplementedNodeKeyManagerServer must be embedded to have forward compatible implementations.
type UnimplementedNodeKeyManagerServer struct {
}

func (UnimplementedNodeKeyManagerServer) GetNodeInfo(context.Context, *GetNodeInfoRequest) (*GetNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedNodeKeyManagerServer) GetNodePlainSize(context.Context, *GetNodePlainSizeRequest) (*GetNodePlainSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodePlainSize not implemented")
}
func (UnimplementedNodeKeyManagerServer) SetNodeInfo(NodeKeyManager_SetNodeInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method SetNodeInfo not implemented")
}
func (UnimplementedNodeKeyManagerServer) CopyNodeInfo(context.Context, *CopyNodeInfoRequest) (*CopyNodeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyNodeInfo not implemented")
}
func (UnimplementedNodeKeyManagerServer) DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedNodeKeyManagerServer) DeleteNodeKey(context.Context, *DeleteNodeKeyRequest) (*DeleteNodeKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodeKey not implemented")
}
func (UnimplementedNodeKeyManagerServer) DeleteNodeSharedKey(context.Context, *DeleteNodeSharedKeyRequest) (*DeleteNodeSharedKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodeSharedKey not implemented")
}
func (UnimplementedNodeKeyManagerServer) mustEmbedUnimplementedNodeKeyManagerServer() {}

// UnsafeNodeKeyManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeKeyManagerServer will
// result in compilation errors.
type UnsafeNodeKeyManagerServer interface {
	mustEmbedUnimplementedNodeKeyManagerServer()
}

func RegisterNodeKeyManagerServer(s grpc.ServiceRegistrar, srv NodeKeyManagerServer) {
	s.RegisterService(&NodeKeyManager_ServiceDesc, srv)
}

func _NodeKeyManager_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/GetNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).GetNodeInfo(ctx, req.(*GetNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeKeyManager_GetNodePlainSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodePlainSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).GetNodePlainSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/GetNodePlainSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).GetNodePlainSize(ctx, req.(*GetNodePlainSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeKeyManager_SetNodeInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NodeKeyManagerServer).SetNodeInfo(&nodeKeyManagerSetNodeInfoServer{stream})
}

type NodeKeyManager_SetNodeInfoServer interface {
	SendAndClose(*SetNodeInfoResponse) error
	Recv() (*SetNodeInfoRequest, error)
	grpc.ServerStream
}

type nodeKeyManagerSetNodeInfoServer struct {
	grpc.ServerStream
}

func (x *nodeKeyManagerSetNodeInfoServer) SendAndClose(m *SetNodeInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nodeKeyManagerSetNodeInfoServer) Recv() (*SetNodeInfoRequest, error) {
	m := new(SetNodeInfoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NodeKeyManager_CopyNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyNodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).CopyNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/CopyNodeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).CopyNodeInfo(ctx, req.(*CopyNodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeKeyManager_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeKeyManager_DeleteNodeKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).DeleteNodeKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/DeleteNodeKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).DeleteNodeKey(ctx, req.(*DeleteNodeKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeKeyManager_DeleteNodeSharedKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeSharedKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeKeyManagerServer).DeleteNodeSharedKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/encryption.NodeKeyManager/DeleteNodeSharedKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeKeyManagerServer).DeleteNodeSharedKey(ctx, req.(*DeleteNodeSharedKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeKeyManager_ServiceDesc is the grpc.ServiceDesc for NodeKeyManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeKeyManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "encryption.NodeKeyManager",
	HandlerType: (*NodeKeyManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodeInfo",
			Handler:    _NodeKeyManager_GetNodeInfo_Handler,
		},
		{
			MethodName: "GetNodePlainSize",
			Handler:    _NodeKeyManager_GetNodePlainSize_Handler,
		},
		{
			MethodName: "CopyNodeInfo",
			Handler:    _NodeKeyManager_CopyNodeInfo_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _NodeKeyManager_DeleteNode_Handler,
		},
		{
			MethodName: "DeleteNodeKey",
			Handler:    _NodeKeyManager_DeleteNodeKey_Handler,
		},
		{
			MethodName: "DeleteNodeSharedKey",
			Handler:    _NodeKeyManager_DeleteNodeSharedKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SetNodeInfo",
			Handler:       _NodeKeyManager_SetNodeInfo_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "cells-encryption.proto",
}
