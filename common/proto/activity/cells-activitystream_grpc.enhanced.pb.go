// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-activitystream.proto

package activity

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedActivityServiceServers     = make(map[string]ActivityServiceEnhancedServer)
	enhancedActivityServiceServersLock = sync.RWMutex{}
)

type NamedActivityServiceServer interface {
	ActivityServiceServer
	Name() string
}
type ActivityServiceEnhancedServer map[string]NamedActivityServiceServer

func (m ActivityServiceEnhancedServer) PostActivity(s ActivityService_PostActivityServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method PostActivity should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PostActivity(s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method PostActivity not implemented")
}

func (m ActivityServiceEnhancedServer) StreamActivities(r *StreamActivitiesRequest, s ActivityService_StreamActivitiesServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method StreamActivities should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.StreamActivities(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method StreamActivities not implemented")
}

func (m ActivityServiceEnhancedServer) UnreadActivitiesNumber(ctx context.Context, r *UnreadActivitiesRequest) (*UnreadActivitiesResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method UnreadActivitiesNumber should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.UnreadActivitiesNumber(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method UnreadActivitiesNumber not implemented")
}

func (m ActivityServiceEnhancedServer) PurgeActivities(ctx context.Context, r *PurgeActivitiesRequest) (*PurgeActivitiesResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PurgeActivities should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PurgeActivities(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PurgeActivities not implemented")
}

func (m ActivityServiceEnhancedServer) SetUserLastActivity(ctx context.Context, r *UserLastActivityRequest) (*UserLastActivityResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method SetUserLastActivity should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.SetUserLastActivity(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method SetUserLastActivity not implemented")
}

func (m ActivityServiceEnhancedServer) Subscribe(ctx context.Context, r *SubscribeRequest) (*SubscribeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Subscribe should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Subscribe(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func (m ActivityServiceEnhancedServer) SearchSubscriptions(r *SearchSubscriptionsRequest, s ActivityService_SearchSubscriptionsServer) error {
	md, ok := metadata.FromIncomingContext(s.Context())
	if !ok || len(md.Get("targetname")) == 0 {
		return status.Errorf(codes.FailedPrecondition, "method SearchSubscriptions should have a context")
	}
	enhancedActivityServiceServersLock.RLock()
	defer enhancedActivityServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.SearchSubscriptions(r, s)
		}
	}
	return status.Errorf(codes.Unimplemented, "method SearchSubscriptions not implemented")
}
func (m ActivityServiceEnhancedServer) mustEmbedUnimplementedActivityServiceServer() {}
func RegisterActivityServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedActivityServiceServer) {
	enhancedActivityServiceServersLock.Lock()
	defer enhancedActivityServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedActivityServiceServers[addr]
	if !ok {
		m = ActivityServiceEnhancedServer{}
		enhancedActivityServiceServers[addr] = m
		RegisterActivityServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterActivityServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedActivityServiceServersLock.Lock()
	defer enhancedActivityServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedActivityServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
