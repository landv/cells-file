// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.18.1
// source: cells-auth.proto

package auth

import (
	context "context"
	fmt "fmt"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	metadata "google.golang.org/grpc/metadata"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedAuthTokenRevokerServers     = make(map[string]AuthTokenRevokerEnhancedServer)
	enhancedAuthTokenRevokerServersLock = sync.RWMutex{}
)

type NamedAuthTokenRevokerServer interface {
	AuthTokenRevokerServer
	Name() string
}
type AuthTokenRevokerEnhancedServer map[string]NamedAuthTokenRevokerServer

// Revoker invalidates the current token and specifies if the invalidation is due to a refresh or a revokation

func (m AuthTokenRevokerEnhancedServer) Revoke(ctx context.Context, r *RevokeTokenRequest) (*RevokeTokenResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Revoke should have a context")
	}
	enhancedAuthTokenRevokerServersLock.RLock()
	defer enhancedAuthTokenRevokerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Revoke(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (m AuthTokenRevokerEnhancedServer) mustEmbedUnimplementedAuthTokenRevokerServer() {}
func RegisterAuthTokenRevokerEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthTokenRevokerServer) {
	enhancedAuthTokenRevokerServersLock.Lock()
	defer enhancedAuthTokenRevokerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenRevokerServers[addr]
	if !ok {
		m = AuthTokenRevokerEnhancedServer{}
		enhancedAuthTokenRevokerServers[addr] = m
		RegisterAuthTokenRevokerServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthTokenRevokerEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthTokenRevokerServersLock.Lock()
	defer enhancedAuthTokenRevokerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenRevokerServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedAuthTokenPrunerServers     = make(map[string]AuthTokenPrunerEnhancedServer)
	enhancedAuthTokenPrunerServersLock = sync.RWMutex{}
)

type NamedAuthTokenPrunerServer interface {
	AuthTokenPrunerServer
	Name() string
}
type AuthTokenPrunerEnhancedServer map[string]NamedAuthTokenPrunerServer

// PruneTokens clear revoked tokens

func (m AuthTokenPrunerEnhancedServer) PruneTokens(ctx context.Context, r *PruneTokensRequest) (*PruneTokensResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PruneTokens should have a context")
	}
	enhancedAuthTokenPrunerServersLock.RLock()
	defer enhancedAuthTokenPrunerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PruneTokens(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PruneTokens not implemented")
}
func (m AuthTokenPrunerEnhancedServer) mustEmbedUnimplementedAuthTokenPrunerServer() {}
func RegisterAuthTokenPrunerEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthTokenPrunerServer) {
	enhancedAuthTokenPrunerServersLock.Lock()
	defer enhancedAuthTokenPrunerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenPrunerServers[addr]
	if !ok {
		m = AuthTokenPrunerEnhancedServer{}
		enhancedAuthTokenPrunerServers[addr] = m
		RegisterAuthTokenPrunerServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthTokenPrunerEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthTokenPrunerServersLock.Lock()
	defer enhancedAuthTokenPrunerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenPrunerServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedLoginProviderServers     = make(map[string]LoginProviderEnhancedServer)
	enhancedLoginProviderServersLock = sync.RWMutex{}
)

type NamedLoginProviderServer interface {
	LoginProviderServer
	Name() string
}
type LoginProviderEnhancedServer map[string]NamedLoginProviderServer

func (m LoginProviderEnhancedServer) GetLogin(ctx context.Context, r *GetLoginRequest) (*GetLoginResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetLogin should have a context")
	}
	enhancedLoginProviderServersLock.RLock()
	defer enhancedLoginProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetLogin not implemented")
}

func (m LoginProviderEnhancedServer) CreateLogin(ctx context.Context, r *CreateLoginRequest) (*CreateLoginResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CreateLogin should have a context")
	}
	enhancedLoginProviderServersLock.RLock()
	defer enhancedLoginProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CreateLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogin not implemented")
}

func (m LoginProviderEnhancedServer) AcceptLogin(ctx context.Context, r *AcceptLoginRequest) (*AcceptLoginResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AcceptLogin should have a context")
	}
	enhancedLoginProviderServersLock.RLock()
	defer enhancedLoginProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AcceptLogin(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogin not implemented")
}
func (m LoginProviderEnhancedServer) mustEmbedUnimplementedLoginProviderServer() {}
func RegisterLoginProviderEnhancedServer(s grpc.ServiceRegistrar, srv NamedLoginProviderServer) {
	enhancedLoginProviderServersLock.Lock()
	defer enhancedLoginProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLoginProviderServers[addr]
	if !ok {
		m = LoginProviderEnhancedServer{}
		enhancedLoginProviderServers[addr] = m
		RegisterLoginProviderServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterLoginProviderEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedLoginProviderServersLock.Lock()
	defer enhancedLoginProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLoginProviderServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedConsentProviderServers     = make(map[string]ConsentProviderEnhancedServer)
	enhancedConsentProviderServersLock = sync.RWMutex{}
)

type NamedConsentProviderServer interface {
	ConsentProviderServer
	Name() string
}
type ConsentProviderEnhancedServer map[string]NamedConsentProviderServer

func (m ConsentProviderEnhancedServer) GetConsent(ctx context.Context, r *GetConsentRequest) (*GetConsentResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method GetConsent should have a context")
	}
	enhancedConsentProviderServersLock.RLock()
	defer enhancedConsentProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.GetConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}

func (m ConsentProviderEnhancedServer) CreateConsent(ctx context.Context, r *CreateConsentRequest) (*CreateConsentResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CreateConsent should have a context")
	}
	enhancedConsentProviderServersLock.RLock()
	defer enhancedConsentProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CreateConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsent not implemented")
}

func (m ConsentProviderEnhancedServer) AcceptConsent(ctx context.Context, r *AcceptConsentRequest) (*AcceptConsentResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AcceptConsent should have a context")
	}
	enhancedConsentProviderServersLock.RLock()
	defer enhancedConsentProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AcceptConsent(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptConsent not implemented")
}
func (m ConsentProviderEnhancedServer) mustEmbedUnimplementedConsentProviderServer() {}
func RegisterConsentProviderEnhancedServer(s grpc.ServiceRegistrar, srv NamedConsentProviderServer) {
	enhancedConsentProviderServersLock.Lock()
	defer enhancedConsentProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedConsentProviderServers[addr]
	if !ok {
		m = ConsentProviderEnhancedServer{}
		enhancedConsentProviderServers[addr] = m
		RegisterConsentProviderServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterConsentProviderEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedConsentProviderServersLock.Lock()
	defer enhancedConsentProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedConsentProviderServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedLogoutProviderServers     = make(map[string]LogoutProviderEnhancedServer)
	enhancedLogoutProviderServersLock = sync.RWMutex{}
)

type NamedLogoutProviderServer interface {
	LogoutProviderServer
	Name() string
}
type LogoutProviderEnhancedServer map[string]NamedLogoutProviderServer

func (m LogoutProviderEnhancedServer) CreateLogout(ctx context.Context, r *CreateLogoutRequest) (*CreateLogoutResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CreateLogout should have a context")
	}
	enhancedLogoutProviderServersLock.RLock()
	defer enhancedLogoutProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CreateLogout(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogout not implemented")
}

func (m LogoutProviderEnhancedServer) AcceptLogout(ctx context.Context, r *AcceptLogoutRequest) (*AcceptLogoutResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method AcceptLogout should have a context")
	}
	enhancedLogoutProviderServersLock.RLock()
	defer enhancedLogoutProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.AcceptLogout(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogout not implemented")
}
func (m LogoutProviderEnhancedServer) mustEmbedUnimplementedLogoutProviderServer() {}
func RegisterLogoutProviderEnhancedServer(s grpc.ServiceRegistrar, srv NamedLogoutProviderServer) {
	enhancedLogoutProviderServersLock.Lock()
	defer enhancedLogoutProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLogoutProviderServers[addr]
	if !ok {
		m = LogoutProviderEnhancedServer{}
		enhancedLogoutProviderServers[addr] = m
		RegisterLogoutProviderServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterLogoutProviderEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedLogoutProviderServersLock.Lock()
	defer enhancedLogoutProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedLogoutProviderServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedAuthCodeProviderServers     = make(map[string]AuthCodeProviderEnhancedServer)
	enhancedAuthCodeProviderServersLock = sync.RWMutex{}
)

type NamedAuthCodeProviderServer interface {
	AuthCodeProviderServer
	Name() string
}
type AuthCodeProviderEnhancedServer map[string]NamedAuthCodeProviderServer

func (m AuthCodeProviderEnhancedServer) CreateAuthCode(ctx context.Context, r *CreateAuthCodeRequest) (*CreateAuthCodeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method CreateAuthCode should have a context")
	}
	enhancedAuthCodeProviderServersLock.RLock()
	defer enhancedAuthCodeProviderServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.CreateAuthCode(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthCode not implemented")
}
func (m AuthCodeProviderEnhancedServer) mustEmbedUnimplementedAuthCodeProviderServer() {}
func RegisterAuthCodeProviderEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthCodeProviderServer) {
	enhancedAuthCodeProviderServersLock.Lock()
	defer enhancedAuthCodeProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthCodeProviderServers[addr]
	if !ok {
		m = AuthCodeProviderEnhancedServer{}
		enhancedAuthCodeProviderServers[addr] = m
		RegisterAuthCodeProviderServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthCodeProviderEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthCodeProviderServersLock.Lock()
	defer enhancedAuthCodeProviderServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthCodeProviderServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedAuthTokenVerifierServers     = make(map[string]AuthTokenVerifierEnhancedServer)
	enhancedAuthTokenVerifierServersLock = sync.RWMutex{}
)

type NamedAuthTokenVerifierServer interface {
	AuthTokenVerifierServer
	Name() string
}
type AuthTokenVerifierEnhancedServer map[string]NamedAuthTokenVerifierServer

// Verifies a token and returns claims

func (m AuthTokenVerifierEnhancedServer) Verify(ctx context.Context, r *VerifyTokenRequest) (*VerifyTokenResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Verify should have a context")
	}
	enhancedAuthTokenVerifierServersLock.RLock()
	defer enhancedAuthTokenVerifierServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Verify(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (m AuthTokenVerifierEnhancedServer) mustEmbedUnimplementedAuthTokenVerifierServer() {}
func RegisterAuthTokenVerifierEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthTokenVerifierServer) {
	enhancedAuthTokenVerifierServersLock.Lock()
	defer enhancedAuthTokenVerifierServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenVerifierServers[addr]
	if !ok {
		m = AuthTokenVerifierEnhancedServer{}
		enhancedAuthTokenVerifierServers[addr] = m
		RegisterAuthTokenVerifierServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthTokenVerifierEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthTokenVerifierServersLock.Lock()
	defer enhancedAuthTokenVerifierServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenVerifierServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedAuthCodeExchangerServers     = make(map[string]AuthCodeExchangerEnhancedServer)
	enhancedAuthCodeExchangerServersLock = sync.RWMutex{}
)

type NamedAuthCodeExchangerServer interface {
	AuthCodeExchangerServer
	Name() string
}
type AuthCodeExchangerEnhancedServer map[string]NamedAuthCodeExchangerServer

func (m AuthCodeExchangerEnhancedServer) Exchange(ctx context.Context, r *ExchangeRequest) (*ExchangeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Exchange should have a context")
	}
	enhancedAuthCodeExchangerServersLock.RLock()
	defer enhancedAuthCodeExchangerServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Exchange(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (m AuthCodeExchangerEnhancedServer) mustEmbedUnimplementedAuthCodeExchangerServer() {}
func RegisterAuthCodeExchangerEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthCodeExchangerServer) {
	enhancedAuthCodeExchangerServersLock.Lock()
	defer enhancedAuthCodeExchangerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthCodeExchangerServers[addr]
	if !ok {
		m = AuthCodeExchangerEnhancedServer{}
		enhancedAuthCodeExchangerServers[addr] = m
		RegisterAuthCodeExchangerServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthCodeExchangerEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthCodeExchangerServersLock.Lock()
	defer enhancedAuthCodeExchangerServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthCodeExchangerServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedPasswordCredentialsTokenServers     = make(map[string]PasswordCredentialsTokenEnhancedServer)
	enhancedPasswordCredentialsTokenServersLock = sync.RWMutex{}
)

type NamedPasswordCredentialsTokenServer interface {
	PasswordCredentialsTokenServer
	Name() string
}
type PasswordCredentialsTokenEnhancedServer map[string]NamedPasswordCredentialsTokenServer

func (m PasswordCredentialsTokenEnhancedServer) PasswordCredentialsToken(ctx context.Context, r *PasswordCredentialsTokenRequest) (*PasswordCredentialsTokenResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method PasswordCredentialsToken should have a context")
	}
	enhancedPasswordCredentialsTokenServersLock.RLock()
	defer enhancedPasswordCredentialsTokenServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.PasswordCredentialsToken(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsToken not implemented")
}
func (m PasswordCredentialsTokenEnhancedServer) mustEmbedUnimplementedPasswordCredentialsTokenServer() {
}
func RegisterPasswordCredentialsTokenEnhancedServer(s grpc.ServiceRegistrar, srv NamedPasswordCredentialsTokenServer) {
	enhancedPasswordCredentialsTokenServersLock.Lock()
	defer enhancedPasswordCredentialsTokenServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedPasswordCredentialsTokenServers[addr]
	if !ok {
		m = PasswordCredentialsTokenEnhancedServer{}
		enhancedPasswordCredentialsTokenServers[addr] = m
		RegisterPasswordCredentialsTokenServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterPasswordCredentialsTokenEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedPasswordCredentialsTokenServersLock.Lock()
	defer enhancedPasswordCredentialsTokenServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedPasswordCredentialsTokenServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedAuthTokenRefresherServers     = make(map[string]AuthTokenRefresherEnhancedServer)
	enhancedAuthTokenRefresherServersLock = sync.RWMutex{}
)

type NamedAuthTokenRefresherServer interface {
	AuthTokenRefresherServer
	Name() string
}
type AuthTokenRefresherEnhancedServer map[string]NamedAuthTokenRefresherServer

func (m AuthTokenRefresherEnhancedServer) Refresh(ctx context.Context, r *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Refresh should have a context")
	}
	enhancedAuthTokenRefresherServersLock.RLock()
	defer enhancedAuthTokenRefresherServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Refresh(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (m AuthTokenRefresherEnhancedServer) mustEmbedUnimplementedAuthTokenRefresherServer() {}
func RegisterAuthTokenRefresherEnhancedServer(s grpc.ServiceRegistrar, srv NamedAuthTokenRefresherServer) {
	enhancedAuthTokenRefresherServersLock.Lock()
	defer enhancedAuthTokenRefresherServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenRefresherServers[addr]
	if !ok {
		m = AuthTokenRefresherEnhancedServer{}
		enhancedAuthTokenRefresherServers[addr] = m
		RegisterAuthTokenRefresherServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterAuthTokenRefresherEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedAuthTokenRefresherServersLock.Lock()
	defer enhancedAuthTokenRefresherServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedAuthTokenRefresherServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}

var (
	enhancedPersonalAccessTokenServiceServers     = make(map[string]PersonalAccessTokenServiceEnhancedServer)
	enhancedPersonalAccessTokenServiceServersLock = sync.RWMutex{}
)

type NamedPersonalAccessTokenServiceServer interface {
	PersonalAccessTokenServiceServer
	Name() string
}
type PersonalAccessTokenServiceEnhancedServer map[string]NamedPersonalAccessTokenServiceServer

func (m PersonalAccessTokenServiceEnhancedServer) Generate(ctx context.Context, r *PatGenerateRequest) (*PatGenerateResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Generate should have a context")
	}
	enhancedPersonalAccessTokenServiceServersLock.RLock()
	defer enhancedPersonalAccessTokenServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Generate(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

func (m PersonalAccessTokenServiceEnhancedServer) Revoke(ctx context.Context, r *PatRevokeRequest) (*PatRevokeResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method Revoke should have a context")
	}
	enhancedPersonalAccessTokenServiceServersLock.RLock()
	defer enhancedPersonalAccessTokenServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.Revoke(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}

func (m PersonalAccessTokenServiceEnhancedServer) List(ctx context.Context, r *PatListRequest) (*PatListResponse, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok || len(md.Get("targetname")) == 0 {
		return nil, status.Errorf(codes.FailedPrecondition, "method List should have a context")
	}
	enhancedPersonalAccessTokenServiceServersLock.RLock()
	defer enhancedPersonalAccessTokenServiceServersLock.RUnlock()
	for _, mm := range m {
		if mm.Name() == md.Get("targetname")[0] {
			return mm.List(ctx, r)
		}
	}
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (m PersonalAccessTokenServiceEnhancedServer) mustEmbedUnimplementedPersonalAccessTokenServiceServer() {
}
func RegisterPersonalAccessTokenServiceEnhancedServer(s grpc.ServiceRegistrar, srv NamedPersonalAccessTokenServiceServer) {
	enhancedPersonalAccessTokenServiceServersLock.Lock()
	defer enhancedPersonalAccessTokenServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedPersonalAccessTokenServiceServers[addr]
	if !ok {
		m = PersonalAccessTokenServiceEnhancedServer{}
		enhancedPersonalAccessTokenServiceServers[addr] = m
		RegisterPersonalAccessTokenServiceServer(s, m)
	}
	m[srv.Name()] = srv
}
func DeregisterPersonalAccessTokenServiceEnhancedServer(s grpc.ServiceRegistrar, name string) {
	enhancedPersonalAccessTokenServiceServersLock.Lock()
	defer enhancedPersonalAccessTokenServiceServersLock.Unlock()
	addr := fmt.Sprintf("%p", s)
	m, ok := enhancedPersonalAccessTokenServiceServers[addr]
	if !ok {
		return
	}
	delete(m, name)
}
